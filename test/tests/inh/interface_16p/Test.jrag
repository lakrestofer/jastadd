// Unambiguous chain of overriding in interfaces
// .grammar: { S ::= E*; abstract E; EA:E ::= H; EB:E ::= H; EC:E ::= H; EAC:E ::= H; EBC:E ::= H; EABC:E ::= H; H;}
// .result: EXEC_PASS
//
// One of the more complex examples:
//               ┌───┐    
//               │ A ◄───┐   eq getChild.foo = 0
//               ├───┤   │
//               │ B ◄─┐ │   eq getChild.foo = 1
//           ┌───┼───┤ │ │
//           │ E │ C │ │ │   eq getChild.foo = 2
//           ├───┴───┤ │ │
//           │       ├─┘ │
//           │ EABC  ├───┘
//           │       │    
//           └───┬───┘    
//               │        
//             ┌─┴─┐      
//             │ H │    inh foo  
//             └───┘   
//         [ H.foo = 2 ]
//   
import static runtime.Test.*;
aspect Test16 {
    interface A { }
    interface B { }
    interface C { }

    B extends A;
    C extends B;

    inh int H.foo();
    eq A.getChild().foo() = 0;
    eq B.getChild().foo() = 1;
    eq C.getChild().foo() = 2;

    EA implements A;
    EB implements B;
    EC implements C;

    EAC implements C;
    EAC implements A;

    EBC implements B;
    EBC implements C;

    EABC implements A;
    EABC implements C;
    EABC implements B;

    public class Test{
	public static void main(String[] args) {
	    H hea = new H();
	    H heb = new H();
	    H hec = new H();
	    H heac = new H();
	    H hebc = new H();
	    H heabc = new H();
            List<E> list = new List<E>();

            list.add(new EA(hea));
            list.add(new EB(heb));
            list.add(new EC(hec));
            list.add(new EAC(heac));
            list.add(new EBC(hebc));
            list.add(new EABC(heabc));
            S s = new S(list);

	    testEquals(0, hea.foo());
	    testEquals(1, heb.foo());
	    testEquals(2, hec.foo());
	    testEquals(2, heac.foo());
	    testEquals(2, hebc.foo());
	    testEquals(2, heabc.foo());
	}
    }
}
