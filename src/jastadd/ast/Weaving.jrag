/* Copyright (c) 2017-2020, The JastAdd Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Lund University nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * This aspect contains attributes for mapping AST types to JRAG attributes.
 *
 * <p>This weaving method is based entirely on attributes and does not
 * rely on imperative modifications of the existing AST.
 */
aspect AttributeWeaving {
  /**
   * Maps AST types, by name, to synthesized attribute declarations.
   *
   * <p>This is computed from top-level attribute declarations and interface
   * introductions from interface types.
   */
  syn lazy Map<String, Collection<SynDecl>> Grammar.synDeclMap() {
    Map<String, Collection<SynDecl>> map = new HashMap<String, Collection<SynDecl>>();
    for (TypeDecl type : getTypeDecls()) {
      map.put(type.name(), new ArrayList<SynDecl>());
    }
    for (SynDecl decl : grammar().synDecls) {
      if (map.containsKey(decl.hostName)) {
        map.get(decl.hostName).add(decl);
      }
    }
    return map;
  }

  /**
   * @return the set of all synthesized declarations for this type declaration.
   */
  syn nta List<SynDecl> TypeDecl.synDecls() {
    List<SynDecl> decls = new List<SynDecl>();
    Collection<SynDecl> parsedDecls = grammar().synDeclMap().get(name());
    if (parsedDecls != null) {
      for (SynDecl decl : parsedDecls) {
        decls.add(decl);
      }
    }
    for (InterfaceDecl iface : implementedInterfaces()) {
      for (SynDecl declInt : iface.synDecls()) {
        Boolean equFlag = false;
        for (SynDecl decl : decls) {
          if (decl.signature().equals(declInt.signature())) {
            equFlag = true;
          }
        }
        if (!equFlag) {
          declInt.hostName = name();
          decls.add(declInt);
        }
      }
    }
    return decls;
  }

  /**
   * Maps AST types, by name, to synthesized attribute equations.
   *
   * <p>This is computed from top-level attribute equations and interface
   * introductions from interface types.
   */
  syn lazy Map<String, Collection<SynEq>> Grammar.synEqMap() {
    Map<String, Collection<SynEq>> map = new HashMap<String, Collection<SynEq>>();
    for (TypeDecl type : getTypeDecls()) {
      map.put(type.name(), new ArrayList<SynEq>());
    }
    for (SynEq equ : grammar().synEqs) {
      if (map.containsKey(equ.hostName)) {
        map.get(equ.hostName).add(equ);
      }
    }
    return map;
  }

  /**
   * @return the set of all synthesized equations for this type declaration.
   */
  syn nta List<SynEq> TypeDecl.synEqs() {
    List<SynEq> equations = new List<SynEq>();
    Collection<SynEq> parsedEqs = grammar().synEqMap().get(name());
      for (SynEq equ : parsedEqs) {
        equations.add(equ);
      }
    for (InterfaceDecl iface : implementedInterfaces()) {
      for (SynEq declInt : iface.synEqs()) {
        Boolean equFlag = false;
        for (SynEq decl : equations){
          if (decl.signature().equals(declInt.signature())) {
            equFlag = true;
          }
        }
        if (!equFlag) {
          SynEq eq = declInt.treeCopyNoTransform();
          eq.hostName = name();
          equations.add(eq);
        }
      }
    }
    return equations;
  }


  /**
   * @return the set of all synthesized nta declarations for this type declaration.
   */
  syn nta List<SynthesizedNta> TypeDecl.synNtaDecls() {
    List<SynthesizedNta> decls = new List<SynthesizedNta>();
    for (SynDecl synDecl : synDecls()) {
      if (synDecl.getNTA()) {
        decls.addChild(new SynthesizedNta(synDecl.getName(), synDecl.getType()));
      }
    }
    return decls;
  }

  /**
   * Maps AST types, by name, to synthesized attribute declarations.
   *
   * <p>This is computed from top-level attribute declarations and interface
   * introductions from interface types.
   */
  syn Map<String, Collection<CollDecl>> Grammar.collDeclMap() {
    Map<String, Collection<CollDecl>> map = new HashMap<String, Collection<CollDecl>>();
    for (TypeDecl type : getTypeDecls()) {
      map.put(type.name(), new ArrayList<CollDecl>());
    }
    for (CollDecl decl : grammar().collDecls) {
      if (map.containsKey(decl.hostName)) {
        map.get(decl.hostName).add(decl);
      }
    }
    return map;
  }

  /**
   * @return the set of all synthesized declarations for this type declaration.
   */
  syn nta List<CollDecl> TypeDecl.collDecls() {
    List<CollDecl> decls = new List<CollDecl>();
    Collection<CollDecl> parsedDecls = grammar().collDeclMap().get(name());
      for (CollDecl decl : parsedDecls) {
        decls.add(decl);
      }
    for (InterfaceDecl iface : implementedInterfaces()) {
      for (CollDecl declInt : iface.collDecls()) {
        Boolean equFlag = false;
        for (CollDecl decl : decls){
          if (decl.signature().equals(declInt.signature())) {
            equFlag = true;
          }
        }
        if (!equFlag) {
          decls.add(declInt);
        }
      }
    }
    return decls;
  }

  /**
   * Maps AST types, by name, to collection attribute equations.
   *
   * <p>This is computed from top-level attribute equations and interface
   * introductions from interface types.
   */
  syn lazy Map<TypeDecl, Collection<CollEq>> Grammar.collEqMap() {
    Map<TypeDecl, Collection<CollEq>> typeDeclMap =
        new HashMap<TypeDecl, Collection<CollEq>>();

    for (TypeDecl type : getTypeDecls()) {
      typeDeclMap.put(type, new ArrayList<CollEq>());
    }

    for (CollEq collEq : grammar().collEqs) {
      TypeDecl target = lookup(collEq.getTarget());

      if (typeDeclMap.containsKey(target)) {
        typeDeclMap.get(target).add(collEq);
      }
    }
    return typeDeclMap;
  }

  /**
   * @return the set of all synthesized equations for this type declaration.
   */
  syn nta List<CollEq> TypeDecl.collEqs() {
    List<CollEq> equations = new List<CollEq>();
    Collection<CollEq> parsedEqs = grammar().collEqMap().get(this);
    for (CollEq equ : parsedEqs) {
      equations.add(equ);
    }
    for (InterfaceDecl iface : implementedInterfaces()) {
      for (CollEq declInt : iface.collEqs()) {
        Boolean equFlag = false;
        for (CollEq decl : equations){
          if (decl.signature().equals(declInt.signature())) {
            equFlag = true;
          }
        }
        if (!equFlag) {
          equations.add(declInt);
        }
      }
    }
    return equations;
  }
}
